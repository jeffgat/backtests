//@version=6
strategy(
     title              = "TP/SL Alert Test",
     overlay            = true,
     initial_capital    = 100000,
     pyramiding         = 0,
     margin_long        = 0,
     margin_short       = 0,
     commission_type    = strategy.commission.cash_per_contract,
     commission_value   = 0.05,
    calc_on_every_tick = true,
     process_orders_on_close = true,
     use_bar_magnifier  = true,
     fill_orders_on_standard_ohlc = false
)

// ----------------------------------------------------------------------------------------
// Inputs
// ----------------------------------------------------------------------------------------
stopPts      = input.float(10.0, "Stop Loss (points)", step=1.0, group="Levels")
tp1Pts       = input.float(10.0, "TP1 (points)", step=1.0, group="Levels")
tp2Pts       = input.float(20.0, "TP2 (points)", step=1.0, group="Levels")
qty          = input.int(2, "Contracts", minval=1, group="Sizing")
beOffsetTicks = input.int(4, "BE Offset (ticks)", step=1, group="Sizing")

// ----------------------------------------------------------------------------------------
// State
// ----------------------------------------------------------------------------------------
var float entryPrice  = na
var bool  beActive    = false
var float filledEntry = na
var bool  tp1Alerted  = false
var float prevPos     = 0

barClosed  = barstate.isconfirmed
beOffset   = beOffsetTicks * syminfo.mintick
halfQty    = math.floor(qty / 2)
isSingle   = qty <= 1
tp1Touch   = strategy.position_size > 0 and not na(entryPrice) and high >= entryPrice + tp1Pts

// Reset when flat
if strategy.position_size == 0
    beActive    := false
    filledEntry := na
    entryPrice  := na
    tp1Alerted  := false

// ----------------------------------------------------------------------------------------
// Entry - market buy on every confirmed bar close if flat
// ----------------------------------------------------------------------------------------
if barClosed and strategy.position_size == 0
    entryPrice := close
    strategy.entry("L", strategy.long, qty=qty)

// Track actual fill price
if strategy.position_size > 0 and na(filledEntry)
    filledEntry := strategy.opentrades.entry_price(0)

// ----------------------------------------------------------------------------------------
// BE detection (mirrors HEAD_orb_prod.pine logic)
// ----------------------------------------------------------------------------------------
if strategy.position_size > 0 and not beActive
    if isSingle
        if tp1Touch
            beActive := true
    else
        positionReduced = strategy.position_size < qty and not na(filledEntry)
        if positionReduced or tp1Touch
            beActive := true

// ----------------------------------------------------------------------------------------
// Exit orders
// ----------------------------------------------------------------------------------------
if strategy.position_size > 0
    stopLevel = not na(entryPrice) ? entryPrice - stopPts : na
    tp1Level  = not na(entryPrice) ? entryPrice + tp1Pts  : na
    tp2Level  = not na(entryPrice) ? entryPrice + tp2Pts  : na
    beStopPrice = (not na(filledEntry) ? filledEntry : entryPrice) + beOffset
    finalStop = beActive ? beStopPrice : stopLevel

    if isSingle
        strategy.exit("L-F", from_entry="L", stop=finalStop, limit=tp2Level, comment_loss=beActive ? "be" : "sl", comment_profit="tp2")
    else
        strategy.exit("L-P", from_entry="L", qty=halfQty, stop=finalStop, limit=tp1Level, comment_loss=beActive ? "be" : "sl", comment_profit="tp1")
        strategy.exit("L-F", from_entry="L", stop=finalStop, limit=tp2Level, comment_loss=beActive ? "be" : "sl", comment_profit="tp2")

// ----------------------------------------------------------------------------------------
// Alert conditions
// ----------------------------------------------------------------------------------------
entrySignal = barClosed and strategy.position_size == 0
tp1Hit      = not isSingle and not tp1Alerted and (
     (strategy.position_size > 0 and strategy.position_size < strategy.position_size[1]) or
     tp1Touch
 )

// ----------------------------------------------------------------------------------------
// Entry alert (mirrors HEAD_orb_prod.pine new architecture)
// ----------------------------------------------------------------------------------------
if entrySignal
    stopPrice = close - stopPts
    if isSingle
        tp2Price = close + tp2Pts
        alert('{"ticker": "MNQ", "action": "buy", "quantity": ' + str.tostring(qty) + ', "takeProfit": {"limitPrice": ' + str.tostring(tp2Price) + '}, "stopLoss": {"type": "stop", "stopPrice": ' + str.tostring(stopPrice) + '}}', alert.freq_once_per_bar_close)
    else
        // Multi contract: full bracket (TP2 + stop), script manages partial exit at TP1
        tp2Price = close + tp2Pts
        alert('{"ticker": "MNQ", "action": "buy", "quantity": ' + str.tostring(qty) + ', "takeProfit": {"limitPrice": ' + str.tostring(tp2Price) + '}, "stopLoss": {"type": "stop", "stopPrice": ' + str.tostring(stopPrice) + '}}', alert.freq_once_per_bar_close)

// ----------------------------------------------------------------------------------------
// TP1 hit alerts (mirrors HEAD_orb_prod.pine new architecture)
// ----------------------------------------------------------------------------------------
if tp1Hit and not isSingle
    beStopPrice = (not na(filledEntry) ? filledEntry : entryPrice) + beOffset
    tp2Price    = not na(entryPrice) ? entryPrice + tp2Pts : na
    // Partial exit at market
    alert('{"ticker": "MNQ", "action": "exit", "quantity": ' + str.tostring(halfQty) + '}', alert.freq_once_per_bar)
    // Cancel old bracket stop + place BE stop for runner
    alert('{"ticker": "MNQ", "action": "sell", "orderType": "stop", "stopPrice": ' + str.tostring(beStopPrice) + ', "quantity": ' + str.tostring(halfQty) + ', "sentiment": "flat", "delay": 3}', alert.freq_once_per_bar)
    // Place TP2 limit for runner (cancel=false to preserve BE stop)
    alert('{"ticker": "MNQ", "action": "sell", "orderType": "limit", "limitPrice": ' + str.tostring(tp2Price) + ', "quantity": ' + str.tostring(halfQty) + ', "sentiment": "flat", "cancel": false, "delay": 5}', alert.freq_once_per_bar)
    tp1Alerted := true

// ----------------------------------------------------------------------------------------
// final exit alert - flatten and cancel remaining orders
// ----------------------------------------------------------------------------------------
flatNow = prevPos != 0 and strategy.position_size == 0
if flatNow
    alert('{"ticker": "MNQ", "action": "exit"}', alert.freq_once_per_bar)

prevPos := strategy.position_size

// ----------------------------------------------------------------------------------------
// Visuals
// ----------------------------------------------------------------------------------------
plotEntry = strategy.position_size > 0 and not na(entryPrice) ? entryPrice : na
plot(plotEntry, "Entry", color=color.white, style=plot.style_linebr, linewidth=1)
plot(not na(plotEntry) ? entryPrice - stopPts : na, "Stop", color=color.red, style=plot.style_linebr, linewidth=1)
plot(not na(plotEntry) ? entryPrice + tp1Pts : na, "TP1", color=color.orange, style=plot.style_linebr, linewidth=1)
plot(not na(plotEntry) ? entryPrice + tp2Pts : na, "TP2", color=color.green, style=plot.style_linebr, linewidth=1)

